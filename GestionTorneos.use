model GestionTorneos

--- Enumerations ---
enum TipoDeporte {Futbol, Baloncesto, Volleyball, Golf, Tenis, Padel}
enum TipoJugador {Suplente, Titular}
enum TipoCategoria {Infantil, Juvenil, Senior, Veterano}
enum TipoCompeticion {Local, Nacional}
--- End Enumerations ---

--- Classes ---
abstract class Persona
  attributes
    nombre: String
    edad: Integer
    DNI: String
end

class Jugador < Persona
  attributes
    deporte: TipoDeporte
    tipoJugador: TipoJugador
    categoria: TipoCategoria
    competicion: TipoCompeticion
end

class Arbitro < Persona
  attributes
    deporte: TipoDeporte
    categoria: TipoCategoria
    disponibilidad: Boolean
    competicion: TipoCompeticion
end

class Entrenador < Persona
  attributes
    deporte: TipoDeporte
    competicion: TipoCompeticion
end

class Narrador < Persona
  attributes
    deporte: TipoDeporte
    categoria: TipoCategoria
    competicion: TipoCompeticion  
end 

class Torneo
  attributes
    nombre: String
    deporte: TipoDeporte
    temporada: Integer
    categoria: TipoCategoria
    competicion: TipoCompeticion
    maxIntegrantesEquipo: Integer
    ganador: Equipo
    partidoJugado: Boolean
end

class Partido 
  attributes
    tipoCategoria: TipoCategoria
    tipoCompeticion: TipoCompeticion
    tipoDeporte: TipoDeporte
    lugar: String
    fecha: String
    hora: String
end

class Equipo 
  attributes
    nombre: String
    deporte: TipoDeporte
    categoria: TipoCategoria
    competicion: TipoCompeticion
    pais: String
end
--- End Classes ---

--- Associations ---
association entrenadorEquipo between
  Entrenador[1..*] role entrenadores
  Equipo[1..*] role equipos
end

association partidoTorneo between
  Partido[1..*] role partidos
  Torneo[1..*] role torneos
end

association arbitroTorneo between
  Arbitro[1..*] role arbitros
  Torneo[0..*] role torneos
end

association narradorTorneo between
  Narrador[1..*] role narradores
  Torneo[0..*] role torneos
end

association arbitroPartido between
  Arbitro[1..*] role arbitros
  Partido[0..*] role partidos
end

association narradorPartido between
  Narrador[1..*] role narradores
  Partido[0..*] role partidos
end

association equipoTorneo between
  Equipo[1..*] role equipos
  Torneo[0..*] role torneos
end
--- End Associations ---

--- Association Classes ---
associationclass TiempoEquipo between
  Jugador[*] role jugadores
  Equipo[*] role equipos
  attributes
    fechaInicio: String
    fechaFin: String
end  

associationclass ParticipacionPartido between
  Partido[0..*] role partidos
  Equipo[1..*] role equipos
  attributes
    esLocal: Boolean
    puntuacion: Integer
end  
--- End Association Classes ---

--- Invariants ---
constraints

context Torneo
  -- No puede haber más integrantes por equipo que el número máximo
  inv MaxIntegrantesEquipo: 
    self.equipos -> forAll(e |
      TiempoEquipo.allInstances()
        -> select(te | te.equipos = e and (te.fechaFin.oclIsUndefined() or te.fechaFin = ''))
        -> size() <= self.maxIntegrantesEquipo
    )

  -- Los tipos del equipo tiene que coincidir con los tipos del torneo
  inv CoherenciaInscripcion:
    self.equipos->forAll(e | 
        e.competicion = self.competicion and
        e.deporte = self.deporte and
        e.categoria = self.categoria
    )

  -- No pueden haber 2 equipos de la misma nacionalidad en un mismo torneo
  inv UnEquipoPorNacionalidad:
    self.competicion = #Nacional implies 
    self.equipos->forAll(e1, e2 | e1 <> e2 implies e1.pais <> e2.pais)

  -- El ganador debe ser un equipo participante del torneo
  inv GanadorEsParticipante:
    not self.ganador.oclIsUndefined() implies self.equipos->includes(self.ganador)  


context Partido
  -- Los equipos participantes deben pertenecer al torneo del partido --
  inv EquiposPertenecenAlTorneo:
    ParticipacionPartido.allInstances()
      -> select(p | p.partidos = self)
      -> forAll(pp | 
          self.torneos->exists(t | t.equipos->includes(pp.equipos))
      )

  -- El deporte, categoría y competición del partido deben coincidir con los del torneo --
  inv ConsistenciaConTorneo:
    self.torneos -> forAll(t | 
      self.tipoDeporte = t.deporte and
      self.tipoCategoria = t.categoria and
      self.tipoCompeticion = t.competicion
    )

  -- No puede haber dos partidos en el mismo lugar, fecha y hora --
  inv UnicidadLugarFechaHora:
    Partido.allInstances()
      ->forAll(p | p = self or
        p.lugar <> self.lugar or
        p.fecha <> self.fecha or
        p.hora <> self.hora
    )

  -- Un partido no puede tener equipos locales y nacionales a la vez --
  inv NoLocalVSNacional:
    self.equipos->forAll(e1, e2 | e1.competicion = e2.competicion)

  inv UnLocalYVisitante:
    self.tipoDeporte <> #Golf implies (
      self.participacionPartido->select(pp | pp.esLocal = true)->size() = 1
      and
      self.participacionPartido->select(pp | pp.esLocal = false)->size() = 1
    )


context Equipo
  -- El número de jugadores en el equipo no puede superar el máximo permitido por torneo --
  inv MaxJugadoresPorTorneo:
    self.torneos->forAll(t |
      TiempoEquipo.allInstances()
        ->select(te | te.equipos = self and (te.fechaFin.oclIsUndefined() or te.fechaFin = ''))
        ->collect(te | te.jugadores)
        ->size() <= t.maxIntegrantesEquipo
    )

  -- Un equipo no puede participar en más de un torneo por temporada --
  inv TorneoUnicoPorTemporada:
    self.torneos->isUnique(t | t.temporada)

  -- La competición del equipo debe coincidir con la de los torneos en los que participa --
  inv ConsistenciaCompeticionConTorneo:
    self.torneos->forAll(t | t.competicion = self.competicion)

  -- Un equipo no puede jugar dos partidos a la misma hora y fecha --  
  inv NoPartidosSimultaneos:
    self.participacionPartido->collect(pp | pp.partidos)
      ->forAll(p1, p2 | 
          (p1 <> p2 and p1.fecha = p2.fecha) 
          implies 
          p1.hora <> p2.hora
      )


context Jugador
  -- Edad deberá ser coherente con la categoría del jugador --
  inv EdadCoherenteConCategoria:
    if self.categoria = #Infantil then
      self.edad >= 6 and self.edad <= 12
    else if self.categoria = #Juvenil then
      self.edad >= 13 and self.edad <= 17
    else if self.categoria = #Senior then
      self.edad >= 18 and self.edad <= 40
    else if self.categoria = #Veterano then
      self.edad > 40
    else
      true
    endif endif endif endif

  -- Deporte del jugador debe coincidir con el de los equipos en los que participa --
  inv DeporteConsistenteConEquipos:
    TiempoEquipo.allInstances()
      ->select(te | te.jugadores = self and (te.fechaFin.oclIsUndefined() or te.fechaFin = ''))
      ->forAll(te | te.equipos.deporte = self.deporte)

  -- Solo puede haber un equipo nacional por jugador --
  inv EquipoNacionalUnico:
    TiempoEquipo.allInstances()
      ->select(te | te.jugadores = self and (te.fechaFin.oclIsUndefined() or te.fechaFin = ''))
      ->collect(te | te.equipos)
      ->flatten()
      ->select(e | e.competicion = #Nacional)
      ->size() <= 1

  -- Los equipos locales en los que participa un jugador no pueden coincidir en temporada --
  inv TemporadaUnicaEquiposLocales:
    let misEquiposLocales = TiempoEquipo.allInstances()
      ->select(te | te.jugadores = self and (te.fechaFin.oclIsUndefined() or te.fechaFin = ''))
      ->collect(te | te.equipos)->flatten()
      ->select(e | e.competicion = #Local)
    in
    misEquiposLocales->forAll(e1, e2 |
        e1 = e2 or
        e1.torneos->forAll(t1 |
           e2.torneos->forAll(t2 | t1.temporada <> t2.temporada)
        )
    )


context Arbitro
  -- Un árbitro no puede arbitrar dos partidos a la misma hora o fecha
  inv PartidoUnicoPorFechaHora:
    self.partidos->forAll(p1, p2 |
      p1 = p2 or
      p1.hora <> p2.hora or
      p1.fecha <> p2.fecha
    )

  -- Un árbitro solo puede arbitrar partidos de su deporte
  inv DeporteConsistenteConPartidos:
    self.partidos -> forAll(p | 
      p.tipoDeporte = self.deporte)  

  -- Un árbitro solo puede arbitrar partidos de su categoría
  inv ArbitraSoloSuCategoria:
    self.partidos-> forAll(p | 
      p.tipoCategoria = self.categoria)


context Entrenador
  -- Un entrenador no puede entrenar a varios equipos que pertenezcan al mismo torneo
  inv UnicoEquipoPorTorneo:
    self.equipos->forAll(e1, e2 | 
      e1 <> e2 implies 
        e1.torneos->intersection(e2.torneos)->isEmpty()
    )

  -- Un entrenador solo puede entrenar equipos de su deporte
  inv DeporteConsistenteConEquipos:
    TiempoEquipo.allInstances()
      ->select(te | te.jugadores = self and (te.fechaFin.oclIsUndefined() or te.fechaFin = ''))
      ->forAll(te | te.equipos.deporte = self.deporte) 


context Narrador
  -- Un narrador solo puede narrar partidos de su deporte
  inv DeporteConsistenteConPartidos:
    self.partidos -> forAll(p | p.tipoDeporte = self.deporte)  

  -- Un narrador solo puede narrar un torneo por temporada
  inv TorneoUnicoPorTemporada:
    self.torneos->isUnique(t | t.temporada)

  -- Un narrador no puede narrar dos partidos simultáneos
  inv NarracionUnicaPorFechaHora:
    self.partidos->forAll(p1, p2 |
      (p1 <> p2 and p1.fecha = p2.fecha) 
      implies
      p1.hora <> p2.hora
    )  


context Persona
  -- El DNI de cada persona debe ser único --
  inv DNIUnico:
    Persona.allInstances()->isUnique(p | p.DNI)

  -- El DNI no puede estar vacío --
  inv DNINoVacio:
    not self.DNI.oclIsUndefined() and self.DNI.size() > 0
--- End Invariants ---    