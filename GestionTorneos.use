enum TipoDeporte {Fútbol, Baloncesto, Volleyball, Golf, Tenis, Pádel}
enum TipoJugador {Suplente, Titular}
enum TipoCategoria {Infantil, Juvenil, Senior, Veterano}
enum TipoCompeticion {Local, Nacional}

--- Classes ---
abstract class Persona
  attributes
    nombre: String
    edad: Integer
    DNI: String
end

class Jugador < Persona
  attributes
    deporte: TipoDeporte
    tipoJugador: TipoJugador
    categoria: TipoCategoria
    competicion: TipoCompeticion
end

class Árbitro < Persona
  attributes
    deporte: TipoDeporte
    categoria: TipoCategoria
    disponibilidad: Boolean
    competicion: TipoCompeticion
end

class Entrenador < Persona
  attributes
    deporte: TipoDeporte
    competicion: TipoCompeticion
end

class Narrador < Persona
  attributes
    deporte: TipoDeporte
    categoria: TipoCategoria
    competicion: TipoCompeticion  
end 

class Torneo
  attributes
    nombre: String
    deporte: TipoDeporte
    temporada: Integer
    categoria: TipoCategoria
    competicion: TipoCompeticion
    maxIntegrantesEquipo: Integer
    ganador: String
    partidoJugado: Boolean
end

class Partido 
  attributes
    tipoCategoria: TipoCategoria
    tipoCompeticion: TipoCompeticion
    tipoDeporte: TipoDeporte
    lugar: String
    fecha: String
    hora: String
end

class Equipo 
  attributes
    nombre: String
    deporte: TipoDeporte
    categoria: TipoCategoria
    competicion: TipoCompeticion
end
--- End Classes ---

--- Associations ---
association entrenadorEquipo between
  Entrenador[1..*] role entrenadores
  Equipo[1..*] role equipos
end

association partidoTorneo between
  Partido[1..*] role partidos
  Torneo[1..*] role torneos
end

association arbitroTorneo between
  Árbitro[1..*] role arbitros
  Torneo[0..*] role torneos
end

association narradorTorneo between
  Narrador[1..*] role narradores
  Torneo[0..*] role torneos
end

association arbitroPartido between
  Árbitro[1..*] role arbitros
  Partido[0..*] role partidos
end

association narradorPartido between
  Narrador[1..*] role narradores
  Partido[0..*] role partidos
end

association equipoTorneo between
  Equipo[1..*] role equipos
  Torneo[0..*] role torneos
end
--- End Associations ---

--- Association Classes ---
associationclass TiempoEquipo between
  Jugador[*] role jugadores
  Equipo[*] role equipos
  attributes
    fechaInicio: String
    fechaFin: String
end  

associationclass ParticipacionPartido between
  Partido[0..*] role partidos
  Equipo[1..*] role equipos
  attributes
    esLocal: Boolean
    puntuacion: Integer
end  
--- End Association Classes ---

--- Invariants ---
constraints

context Torneo
  -- No puede haber más integrantes por equipo que el número máximo
  inv MaxIntegrantesEquipo: 
    self.equipos->forAll(e | e.tiempoEquipo->select(te | te.fechaFin = '' or te.fechaFin.oclIsUndefined())->size() <= self.maxIntegrantesEquipo)

  -- Los tipos del equipo tiene que coincidir con los tipos del torneo
  inv CoherenciaInscripcion:
    self.equipos->forAll(e | 
        e.competicion = self.competicion and
        e.deporte = self.deporte and
        e.categoria = self.categoria
    )

  -- No pueden haber 2 equipos de la misma nacionalidad en un mismo torneo
  inv UnEquipoPorNacionalidad:
    self.competicion = #Nacional implies self.equipos->forAll(e1, e2 | e1 <> e2 implies e1.pais <> e2.pais)  

  -- El ganador debe ser un equipo participante del torneo
  inv GanadorEsParticipante:
    (self.ganador.oclIsUndefined() = false and self.ganador <> '') implies self.equipos->exists(e | e.nombre = self.ganador)  

    
context Partido

context Equipo

  -- El número de jugadores en el equipo no puede superar el máximo permitido por torneo --
  inv MaxJugadoresPorTorneo:
    self.torneos->forAll(t | self.jugadores->size <= t.maxIntegrantesEquipo)

  -- Un equipo no puede participar en más de un torneo por temporada --
  inv TorneoUnicoPorTemporada:
    self.torneos->forAll(t1, t2 | t1 <> t2 implies t1.temporada <> t2.temporada)

  -- La competición del equipo debe coincidir con la de los torneos en los que participa --
  inv ConsistenciaCompeticionConTorneo:
    self.torneos->forAll(t | t.competicion = self.competicion)


context Jugador
  -- Edad deberá ser coherente con la categoría del jugador --
  inv EdadCoherenteConCategoría:
    if self.categoria = TipoCategoria::Infantil then
      self.edad >= 6 and self.edad <= 12
    else if self.categoria = TipoCategoria::Juvenil then
      self.edad >= 13 and self.edad <= 17
    else if self.categoria = TipoCategoria::Senior then
      self.edad >= 18 and self.edad <= 40
    else if self.categoria = TipoCategoria::Veterano then
      self.edad > 40
    else
      true
    endif endif endif endif

  -- Deporte del jugador debe coincidir con el de los equipos en los que participa --
  inv  DeporteConsistenteConEquipos:
    self.equipos -> forAll(e | e.deporte = self.deporte)

  -- Solo puede haber un equipo nacional por jugador --
  inv EquipoNacionalUnico:
    self.equipos -> select(e | e.competicion = TipoCompeticion::Nacional) -> size <=1

  -- Los equipos locales en los que participa un jugador no pueden coincidir en temporada --
  inv TemporadaUnicaEquiposLocales:
  self.equipos->select(e | e.competicion = TipoCompeticion::Local)->forAll(e1, e2 |
    e1 <> e2 implies
      e1.torneos->forAll(t1 |  -- Para cada torneo (t1) del equipo local e1
        e2.torneos->forAll(t2 | -- Y cada torneo (t2) del equipo local e2
          t1.temporada <> t2.temporada -- Las temporadas DEBEN ser distintas
        )
      )
  )

end

context Árbitro

context Entrenador
  -- Un entrenador no puede entrenar a varios equipos que pertenezcan al mismo torneo
  inv UnicoEquipoPorTorneo:
    self.equipos->forAll(e1, e2 | e1 <> e2 implies 
        e1.torneos->intersection(e2.torneos)->isEmpty()
    )

  -- Un entrenador solo puede entrenar equipos de su deporte
  inv DeporteConsistenteConEquipos:
    self.equipos -> forAll(e | e.deporte = self.deporte)  

context Narrador

context Persona
  -- El DNI de cada persona debe ser único --
  inv DNIUnico:
    Persona.allInstances()->isUnique(p | p.DNI)

  inv DNINoVacio:
    self.dni.oclIsUndefined() and self.dni->size > 0
end
